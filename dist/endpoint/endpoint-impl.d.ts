import { EndpointOptions, EndpointSpec } from "../endpoint";
import { jsPlumbInstance, OffsetAndSize, Size } from "../core";
import { ComputedAnchorPosition } from "../factory/anchor-factory";
import { Anchor } from "../anchor/anchor";
import { OverlayCapableComponent } from "../component/overlay-capable-component";
import { Connection } from "../connector/connection-impl";
import { PaintStyle } from "../styles";
import { ConnectorSpec } from "../connector";
import { EndpointRepresentation } from "./endpoints";
import { OverlaySpec } from "..";
export declare class Endpoint<E> extends OverlayCapableComponent<E> {
    instance: jsPlumbInstance<E>;
    getIdPrefix(): string;
    getTypeDescriptor(): string;
    getXY(): {
        x: number;
        y: number;
    };
    connections: Array<Connection<E>>;
    connectorPointerEvents: string;
    anchor: Anchor;
    endpoint: EndpointRepresentation<E, any>;
    element: E;
    elementId: string;
    dragAllowedWhenFull: boolean;
    scope: string;
    timestamp: string;
    maxConnections: number;
    connectorClass: string;
    connectorHoverClass: string;
    _originalAnchor: any;
    deleteAfterDragStop: boolean;
    finalEndpoint: Endpoint<E>;
    isSource: boolean;
    isTarget: boolean;
    isTemporarySource: boolean;
    connectionsDirected: boolean;
    connectionsDetachable: boolean;
    reattachConnections: boolean;
    referenceEndpoint: Endpoint<E>;
    connectionType: string;
    connector: ConnectorSpec;
    connectorOverlays: Array<OverlaySpec>;
    connectorStyle: PaintStyle;
    connectorHoverStyle: PaintStyle;
    dragProxy: any;
    deleteOnEmpty: boolean;
    defaultLabelLocation: [number, number];
    getDefaultOverlayKey(): string;
    constructor(instance: jsPlumbInstance<E>, params: EndpointOptions<E>);
    private _updateAnchorClass;
    private prepareAnchor;
    setPreparedAnchor(anchor: Anchor, doNotRepaint?: boolean): Endpoint<E>;
    setAnchor(anchorParams: any, doNotRepaint?: boolean): Endpoint<E>;
    addConnection(conn: Connection<E>): void;
    detachFromConnection(connection: Connection<E>, idx?: number, doNotCleanup?: boolean): void;
    deleteEveryConnection(params?: any): void;
    detachFrom(targetEndpoint: Endpoint<E>, fireEvent?: boolean, originalEvent?: Event): Endpoint<E>;
    setVisible(v: boolean, doNotChangeConnections?: boolean, doNotNotifyOtherEndpoint?: boolean): void;
    applyType(t: any, doNotRepaint: boolean, typeMap: any): void;
    isEnabled(): boolean;
    setEnabled(e: boolean): void;
    destroy(force?: boolean): void;
    isFull(): boolean;
    isFloating(): boolean;
    isConnectedTo(endpoint: Endpoint<E>): boolean;
    getConnectionCost(): number;
    setConnectionCost(c: number): void;
    areConnectionsDirected(): boolean;
    setConnectionsDirected(b: boolean): void;
    setElementId(_elId: string): void;
    setReferenceElement(_el: E | string): void;
    setDragAllowedWhenFull(allowed: boolean): void;
    equals(endpoint: Endpoint<E>): boolean;
    getUuid(): string;
    computeAnchor(params: any): [number, number, number, number];
    setElement(el: E): Endpoint<E>;
    connectorSelector(): Connection<E>;
    paint(params: {
        timestamp?: string;
        offset?: OffsetAndSize;
        dimensions?: Size;
        recalc?: boolean;
        elementWithPrecedence?: string;
        connectorPaintStyle?: PaintStyle;
        anchorLoc?: ComputedAnchorPosition;
    }): void;
    prepareEndpoint<C>(ep: EndpointSpec, typeId?: string): EndpointRepresentation<E, C>;
    setEndpoint(ep: EndpointSpec): void;
    setPreparedEndpoint<C>(ep: EndpointRepresentation<E, C>): void;
    addClass(clazz: string, dontUpdateOverlays?: boolean): void;
    removeClass(clazz: string, dontUpdateOverlays?: boolean): void;
}
