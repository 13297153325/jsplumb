import { Renderer } from "../renderer";
import { Segment } from "../connector/abstract-segment";
import { Component, RepaintOptions } from "../component/component";
import { EndpointRepresentation } from "../endpoint/endpoints";
import { jsPlumbInstance, TypeDescriptor } from "../core";
import { Overlay } from "../overlay/overlay";
import { AbstractConnector } from "../connector/abstract-connector";
import { LabelOverlay } from "../overlay/label-overlay";
import { BrowserJsPlumbInstance, OverlayCapableComponent, PaintStyle } from "..";
export declare type EndpointHelperFunctions = {
    makeNode: (instance: jsPlumbInstance<any>, ep: any, paintStyle: PaintStyle) => void;
    updateNode: (ep: any, node: SVGElement) => void;
};
export declare function registerEndpointRenderer<C>(name: string, fns: EndpointHelperFunctions): void;
export declare class BrowserRenderer implements Renderer<HTMLElement> {
    instance: BrowserJsPlumbInstance;
    getPath(segment: Segment, isFirstSegment: boolean): string;
    repaint(component: Component<HTMLElement>, typeDescriptor: string, options?: RepaintOptions): void;
    private static getLabelElement;
    private static getCustomElement;
    private static cleanup;
    private static setVisible;
    addOverlayClass(o: Overlay<HTMLElement>, clazz: string): void;
    removeOverlayClass(o: Overlay<HTMLElement>, clazz: string): void;
    paintOverlay(o: Overlay<HTMLElement>, params: any, extents: any): void;
    setOverlayVisible(o: Overlay<HTMLElement>, visible: boolean): void;
    moveOverlayParent(o: Overlay<HTMLElement>, newParent: HTMLElement): void;
    reattachOverlay(o: Overlay<HTMLElement>, c: OverlayCapableComponent<HTMLElement>): any;
    setOverlayHover(o: Overlay<HTMLElement>, hover: boolean): any;
    destroyOverlay(o: Overlay<HTMLElement>): void;
    drawOverlay(o: Overlay<HTMLElement>, component: any, paintStyle: PaintStyle, absolutePosition?: [number, number]): any;
    updateLabel(o: LabelOverlay<HTMLElement>): void;
    setHover(component: Component<HTMLElement>, hover: boolean): void;
    paintConnector(connector: AbstractConnector<HTMLElement>, paintStyle: PaintStyle, extents?: any): void;
    setConnectorHover(connector: AbstractConnector<HTMLElement>, h: boolean, doNotCascade?: boolean): void;
    destroyConnector(connector: AbstractConnector<HTMLElement>): void;
    addConnectorClass(connector: AbstractConnector<HTMLElement>, clazz: string): void;
    removeConnectorClass(connector: AbstractConnector<HTMLElement>, clazz: string): void;
    getConnectorClass(connector: AbstractConnector<HTMLElement>): string;
    setConnectorVisible(connector: AbstractConnector<HTMLElement>, v: boolean): void;
    applyConnectorType(connector: AbstractConnector<HTMLElement>, t: TypeDescriptor): void;
    addEndpointClass<C>(ep: EndpointRepresentation<HTMLElement, C>, c: string): void;
    applyEndpointType<C>(ep: EndpointRepresentation<HTMLElement, C>, t: TypeDescriptor): void;
    destroyEndpoint<C>(ep: EndpointRepresentation<HTMLElement, C>): void;
    paintEndpoint<C>(ep: EndpointRepresentation<HTMLElement, C>, paintStyle: PaintStyle): void;
    removeEndpointClass<C>(ep: EndpointRepresentation<HTMLElement, C>, c: string): void;
    getEndpointClass<C>(ep: EndpointRepresentation<HTMLElement, C>): string;
    setEndpointHover<C>(endpoint: EndpointRepresentation<HTMLElement, C>, h: boolean, doNotCascade?: boolean): void;
    setEndpointVisible<C>(ep: EndpointRepresentation<HTMLElement, C>, v: boolean): void;
}
